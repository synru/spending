<head>
  <!-- Load plotly.js into the DOM -->
  <script src='https://cdn.plot.ly/plotly-2.14.0.min.js'></script>
  <!--<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>-->
  <script src="https://d3js.org/d3.v4.min.js">  </script>
  <script src="https://d3js.org/d3-color.v1.min.js">  </script>
  <script src="https://d3js.org/d3-interpolate.v1.min.js">  </script>
  <script src="https://d3js.org/d3-scale-chromatic.v1.min.js">  </script>
  <!-- for multiple select dropdown-->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.js"></script>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap.min.css">
  <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>

  <script
    src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap-multiselect/0.9.13/js/bootstrap-multiselect.js"></script>
  <link rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap-multiselect/0.9.13/css/bootstrap-multiselect.css">
  <script src="https://synru.github.io/spending/graph_ql.js"/>
</head>

<body>
  <style>
    .grid {
      display: flex;
      flex-direction: row;
    }

    .flex-item {
      height: 90%;
      width: 100%;
      background: white;
      flex-grow: 1;
      margin-bottom: 10px;
      margin-right: 10px;
    }
  </style>
<!--  <div class="container" data-num="0">-->
    <div class="control-category">
      Category: <select id="select-cats" multiple="multiple">
      </select>
    </div>
    <div id='plotdiv' class="flex-item"></div>
  <!--</div>-->

  <script></script>

    async function startFetchTreeMapData() {


      var layout = {
        colorway: [],
        barmode: 'stack',
        autosize: true,
        grid: { rows: 3, columns: 3, pattern: 'independent' },
        annotations: [{
          text: "Category Contribution",
          showarrow: false,
          align: 'center',
          x: 0.15,
          y: 0.8,
          xref: 'paper',
          yref: 'paper',
        },
        {
          text: "Weekly Spending Trend",
          showarrow: false,
          align: 'center',
          x: 0.15,
          y: 0.5,
          xref: 'paper',
          yref: 'paper',
        }
        ],
        /*
        xaxis: {
          domain: [0, 1],
          anchor: 'y1'
        },
        yaxis: {
          domain: [0.85, 1],
          anchor: 'x1'
        },
        */
        xaxis: {
          domain: [0.55, 1],
          anchor: 'y1',
          title: {
            text: 'Importance Index',
          },
        },
        yaxis: {
          domain: [0.45, 0.8],
          anchor: 'x1',
          title: {
            text: 'Weekly Spending (£)',
          }
        },
        xaxis3: {
          domain: [0, 0.4],
          anchor: 'y3',
          title: { text: "Week" },
        },
        yaxis3: {
          domain: [0, 0.4],
          anchor: 'x3',
          title: { text: "Spending" },
          tickprefix: '£'
        },
        xaxis4: {
          tickmode: "array",
          domain: [0.55, 1],
          anchor: 'y4'
        },
        yaxis4: {
          title: 'Weekly Spent',
          domain: [0, 0.4],
          anchor: 'x4'
        },

        yaxis5: {
          title: 'Accumulated Weekly Spent',
          overlaying: 'y4',
          side: 'right'
        },

        xaxis6: {
          title: "Test",
          domain: [0.0, 1]
        },
        yaxis6: {
          title: "Test",
          domain: [0.85, 1]
        },

        legend: {
          //x: 0.55,
          //xanchor: 'top'
          y: 0.8
        },
        title3: {
          text: 'Plot Title',
        }

      };

      data = await retrieveData("spending_by_sub_cat")

      res = data.Spending_Sub_Category_Weekly_Spent
      //const res = d3.csvParse(data);
      //delete res["columns"];
      var subcats = res.map(item => item['Sub_Category']);
      var cats = res.map((item, index) => subcats[index] == item['Category'] ? "" : item['Category']);
      //var weeklySpent = res.map(item => parseFloat(item['Weekly_Spent'].replace(/[£,]+/g, "")));
      var weeklySpent = res.map(item => item['Weekly_Spent']);

      var uniqueCats = [...new Set(cats)].filter(cat => !subcats.includes(cat) && cat != "")

      //var catSelectData = []
      var catSelector = $("#select-cats")

      for (cat of uniqueCats) {
        //catSelectData.push(res.filter(entry => entry.Category == cat).map(entry => entry.Sub_Category))
        var optGroup = $("<optgroup/>");
        optGroup.attr("label", cat);
        for (o of res.filter(entry => entry.Category == cat)) {
          var opt = $("<option/>")
          opt.text(o.Sub_Category)
          optGroup.append(opt)
        }
        catSelector.append(optGroup)
      }


      $(document).ready(function () {
        catSelector.multiselect({
          enableClickableOptGroups: true,
          enableCollapsibleOptGroups: true,
          includeSelectAllOption: true,
          onDropdownHidden: function (e) {
            console.log($("#select-cats").val())
            //alert('Changed option ' + $(option).val() + '.');
          }
        });
      });


      //var innerContainer = document.querySelector('[data-num="0"'),
      //  plotEl = innerContainer.querySelector('.plot'),
      //  catSelector = innerContainer.querySelector('.categorydata');

      const cmap = new Map();

      var idx = 0;

      for (cat of [...new Set(res.map(item => item['Category']))]) {
        cmap.set(cat, d3.schemeCategory20[idx++])
      }


      var labels = subcats.concat(uniqueCats)

      var values = weeklySpent.concat(uniqueCats.map((cat, index) => res.filter(item => item["Category"] == cat).map(item => item['Weekly_Spent']).reduce((partialSum, a) => partialSum + a, 0)));
      var parents = cats.concat(new Array(uniqueCats.length).fill(""))

      layout.treemapcolorway = parents.reduce(function (a, e, i) {
        if (e === '')
          a.push(i);
        return a;
      }, []).map((cat, idx) => ({ Cat: labels[cat], Value: values[cat] })).sort((a, b) => b.Value - a.Value).map(pair => cmap.get(pair.Cat))

      //var labels = ["Eve", "Cain", "Seth", "Enos", "Noam", "Abel", "Awan", "Enoch", "Azura"]
      //var parents = ["", "Eve", "Eve", "Seth", "Seth", "Eve", "Eve", "Awan", "Eve"]
      var plot1 = {
        type: "treemap",
        parents: parents,
        labels: labels,
        values: values,
        //textinfo: "label+value+percent parent+percent entry",
        textinfo: "label",
        domain: { "x": [0, 0.45], "y": [0.45, 0.8] },
        //outsidetextfont: { "size": 20, "color": "#377eb8" },
        marker: { "line": { "width": 0 } },
        pathbar: { "visible": false },
        //count: "branches+leaves",
        branchvalues: "total",
        hovertemplate: "%{label}: £%{value:.2f}"
      };

      var pdata = [plot1]
      layout.colorway.push('#aec7e8')

      //console.log(pdata)
      //Plotly.newPlot('demo', [plot1], layout)

      for (cat of uniqueCats) {
        let res1 = res.filter(entry => entry.Category == cat)
        var plot2 = {
          x: res1.map(item => item['Avg_Importance_Index']),
          y: res1.map(item => item['Days_Between_Purchase']),
          xaxis: 'x1',
          yaxis: 'y1',
          mode: 'markers+text',
          type: 'scatter',
          //name: 'Team A',
          text: res1.map(item => item['Sub_Category']),
          //textposition: 'top center',
          //textfont: {
          //  family: 'Raleway, sans-serif'
          //},
          marker: { size: res1.map(item => item['Weekly_Spent']), color: cmap.get(cat) },
          showlegend: false
        };
        pdata.push(plot2)
        layout.colorway.push(cmap.get(cat))
      }



      data = await retrieveData("query_weekly_spent")


      res = data.Spending_Spent_By_Week_Cat

      var helper = {};
      var result = res.reduce(function (r, o) {
        var key = o.Category + '-' + o.Week_Number;

        if (!helper[key]) {
          helper[key] = Object.assign({}, o); // create a copy of o
          r.push(helper[key]);
        } else {
          helper[key].Weekly_Spent += o.Weekly_Spent;
        }

        return r;
      }, []);

      result.sort((a, b) => (a.Week_Number > b.Week_Number) ? 1 : ((b.Week_Number > a.Week_Number) ? -1 : 0))

      var cats = result.map(item => item['Category']);
      var weekNums = result.map(item => item['Week_Number']);
      var weeklySpent = result.map(item => item['Weekly_Spent']);

      var distCats = cats.filter((v, i, a) => a.indexOf(v) === i)//Array.from(new Set(cats));

      for (cat of distCats) {
        let indices = cats.reduce(function (a, e, i) {
          if (e === cat)
            a.push(i);
          return a;
        }, []);

        let xvalues = weekNums.filter((value, index) => {
          return indices.includes(index)
        });

        let yvalues = weeklySpent.filter((value, index) => {
          return indices.includes(index)
        });


        let t = {
          x: xvalues,
          y: yvalues,
          text: new Array(indices.length).fill(cat),
          xaxis: 'x3',
          yaxis: 'y3',
          name: cat,
          type: 'bar'
        };

        pdata.push(t)
        layout.colorway.push(cmap.get(cat))
      }

      //layout.colorway = distCats.map((cat) =>(cmap.get(cat)))

      data = await retrieveData("query_item_spent")

      res = data.Spending_Spent_By_Item
      res.sort((a, b) => (a.Importance_Index > b.Importance_Index) ? 1 : ((b.Importance_Index > a.Importance_Index) ? -1 : 0))

      var helper = {};
      var prevO = null

      result = res.map((obj, index, self) => {
        if (index == 0) {
          prevO = { "Category": obj.Category, "Item": obj.Item, "Importance_Index": obj.Importance_Index, "Accumulated_Spent": obj.Weekly_Spent, "Weekly_Spent": obj.Weekly_Spent }
          return prevO;
        }
        prevO = { "Category": obj.Category, "Item": obj.Item, "Importance_Index": obj.Importance_Index, "Accumulated_Spent": prevO.Accumulated_Spent + obj.Weekly_Spent, "Weekly_Spent": obj.Weekly_Spent }
        return prevO
      });

      for (cat of distCats) {
        var res1 = result.filter(v => (v.Category == cat))
        var items = res1.map(item => item['Item']);
        var importanceIndex = res1.map(item => item['Importance_Index']);
        //var accumulatedSpent = res1.map(item => item['Accumulated_Spent']);
        var weeklySpent = res1.map(item => item['Weekly_Spent']);

        let t = {
          x: importanceIndex,
          y: weeklySpent,
          text: items,
          xaxis: 'x4',
          yaxis: 'y4',
          type: 'bar',
          showlegend: false
        };

        pdata.push(t)
        layout.colorway.push(cmap.get(cat))
      }


      var trace2 = {
        x: result.map(item => item['Importance_Index']),
        y: result.map(item => item['Accumulated_Spent']),
        mode: 'lines',
        xaxis: 'x4',
        yaxis: 'y5',
        showlegend: false
      };

      pdata.push(trace2);
      layout.colorway.push("grey")

      layout.xaxis4.tickvals = result.map(item => item['Importance_Index']);
      layout.xaxis4.ticktext = result.map(item => item['Item']);



      data = await retrieveData("query_summary")

      res = data.Spending_Purchase_aggregate
      let ttlSpent = res["aggregate"]["sum"]["Amount"]
      let numDays = (Date.parse(res["aggregate"]["max"]["Date"]) - Date.parse(res["aggregate"]["min"]["Date"])) / 1000 / 24 / 60 / 60 + 1

      let ttlRecurrent = data.Spending_Recurrent_Weekly_Spent_aggregate.aggregate.sum.Weekly_Spent

      let ttlWeeklySpent = ttlSpent / numDays * 7
      let ttlRecurrentWeeklySpent = ttlRecurrent
      let ttlNonrecurrent = ttlSpent - ttlRecurrent * numDays / 7
      const gbpFormatter = new Intl.NumberFormat('en-GB', {
        style: 'currency',
        currency: 'GBP', maximumFractionDigits: 0
      });

      var data = {
        type: 'table',
        //xaxis: "x",
        //yaxis: "y",
        domain: { x: [0, 0.5], y: [0.85, 1] },
        header: {
          values: ['Weekly Spent', 'Recurrent Weekly', 'Total Non Recurrent'],
          align: "center",
          line: { width: 0, color: 'black' },
          //fill: { color: "grey" },
          font: { size: 20 }
        },
        cells: {
          values: [gbpFormatter.format(ttlWeeklySpent), gbpFormatter.format(ttlRecurrentWeeklySpent), gbpFormatter.format(ttlNonrecurrent)],
          align: "center",
          line: { color: "black", width: 0 },
          font: { size: 40 }
        }
      }

      pdata.push(data);

      Plotly.newPlot('plotdiv', pdata, layout, {
        'displayModeBar': false,
        responsive: true
      });
    }

    startFetchTreeMapData();


  </script>
</body>